import React, { useCallback } from 'react';
import classnames from 'classnames';
// так как JS это язык с динамической типизацией, то для осуществления хоть какого-то контроля над
// типами данных (в данном случае речь о пропах) используется библиотека "prop-types"
// ВАЖНО: проверка пропов на соответствие типам производится по соображениям производительности
// ТОЛЬКО В РЕЖИМЕ РАЗРАБОТКИ!
import PropTypes from 'prop-types';
// для подключения стилей к компоненту нам нужно сделать их импорт, он судя по всему работает как
// импорт по умолчанию, то есть мы можем импортировать их под любым валидным именем
import styles from './Button.module.scss';

// В этом компоненте попробуем рассмотреть общий порядок действий при создании кнопки на React'е!
// Любой компонент в React'е может быть написан либо с использованием синтаксиса функциональных
// компонентов, либо синтаксиса классов. Мы будем использовать синтаксис функциональных компонентов, так
// как он более чистый и менее многословный.
// НО! Могут быть случаи, когда нужно писать "на классах": например, нужно задействовать какой-то особенный
// метод жизненного состояния.

// И так, функциональный компонент объявляется 2 способами (это даже не фишка Реакта, а фишка JS):
// 1) как function declaration:
// function Button() {
// 	return <button>Click me!</button>;
// }

// 2) как function expression(мы будем использовать этот способ!):
// Компонент может принимать объект props (а может и НЕ принимать!) и использовать в рамках расчёта
// своего JSX (UI).
const Button = (props) => {
	// В объекте props можно передавать в принципе всё, что угодно:
	const { color, size, className, children, type, onClick, disabled, style, name, containerName } = props;
	// где, например:
	// - color, size, className, style - свойства, которые позволяют нам определить стили для компонента;
	// - children - свойство, которое позволяет отрисовать то, что в нём передано;
	// - type - тип кнопки (button, submit и так далее);
	// - onClick - обработчик события onClick. Мы передаём его сверху, так как такой подход позволяет сделать кнопку более
	// гибкой: визуально кнопка может быть идентична, но её поведение мы определяем в родительском компоненте, так как
	// в одном компоненте нам нужно, чтобы кнопка сабмитила форму, в другом выводила что-нибудь в консоль и т.д.
	// - disabled - свойство, которое позволяет управлять сверху состоянием кнопки;
	// - name - свойство, которое наверное нужно в этом случае больше для тестирования, чтобы потом можно было по этому
	// атрибуту найти элемент.
	//
	// с помощью библиотеки classname мы можем сформировать итоговые стили элемента
	const buttonClass = classnames(styles[`wrapper-${color}`], styles[`wrapper-${size}`], className);
	//
	// По-хорошему коллбэки нужно объявлять до return и в идеале использовать хук useCallback, который
	// позволяет вернуть ОДНУ И ТУ ЖЕ ССЫЛКУ, если указанные зависимости НЕ ПОМЕНЯЛИСЬ, что позволяет
	// дочерним компонентам, получающим коллбэки (а это конечно же происходит по ссылке, так как функции
	// являются ссылочными типами), сравнить старую и новую ссылки и убедиться в том, что они равны и лишний раз
	// не перерисовываться.
	// Есть даже мнение, что некоторые функции, которые могут использоваться в компоненте, имеет смысл размещать вообще
	// до объявления компонента! Это как правило некие утилитарные функции, которые могут выполнять вспомогательную
	// работу и в качестве коллбэков, которые вызываются в ответ на события, НЕ используются. Но наверное лучше такие функции
	// выносить в принципе из компонента в отдельный модуль с утилитами / хелперами и просто импортировать.
	//
	// ВАЖНО: как правило обработчики событий кнопок приходят СВЕРХУ, так как нажатие кнопки должно вызывать
	// какую-то реакцию в другом компоненте (и именно оттуда мы прокидываем обработчик).
	const onClickHandler = useCallback(() => {
		console.log('Button clicked!');
	}, []);

	// Если props не обязательны, то возврат из компонента JSX ОБЯЗАТЕЛЕН!
	return (
		// как правило кнопки "в вакууме"(без интерактива) в приложении не особо интересны
		// поэтому мы "прикрепляем" обработчик путём добавления ссылки на него в атрибут интересующего
		// нас события. На кнопках это как правило "onClick".
		<button
			// для того, чтобы применить стили к DOM-узлу, нужно:
			// 1) Использовать атрибут "className" (в чистом HTML используется атрибут class, но в JS это reserved word)
			// 2) Затем сослаться на нужное правило в объекте styles.
			className={styles.mySexyButton}
			// Мы можем в качестве обработчика передавать как (1)ссылку на ранее объявленную функцию:
			onClick={onClickHandler}
			// Также из объекта props мы можем взять тип кнопки (если мы конечно его передали сверху)
			type={type}
		>
			{/*// так и (2)инлайново объявленный коллбэк:*/}
			{/*<button onClick={() => console.log('Button clicked!')}>*/}
			{/*с помощью специального свойства объекта props "children" можно прокидывать любое содержимое*/}
			{/*часто это просто текстовое содержимое*/}
			{props.children}
		</button>
	);
};

// const Button1 = (props) => {
// 	// Если props не обязательны, то возврат из компонента JSX ОБЯЗАТЕЛЕН!
// 	return (
// 		<button>
// 			{/*с помощью специального свойства объекта props "children" можно прокидывать любое содержимое*/}
// 			{/*часто это просто текстовое содержимое*/}
// 			Default export
// 			{props.children}
// 		</button>
// 	)
// };

// если мы хотим быть красавчиками, то нужно обязательно описать типы пропов с помощью PropTypes
Button.propTypes = {
	className: PropTypes.string,
	color: PropTypes.oneOf(['primary', 'secondary', 'accent', 'light-primary', 'light-secondary']),
	size: PropTypes.oneOf(['sm', 'md', 'lg']),
	type: PropTypes.string,
	onClick: PropTypes.func,
	disabled: PropTypes.bool,
	name: PropTypes.string,
	containerName: PropTypes.string,
};

// а если мы хотим, чтобы нам поклонялись, то мы просто обязаны задать пропы по умолчанию
// это позволит пропам ВСЕГДА иметь значение (даже если мы из родительского компонента их не передали)
// ВАЖНО! Проверка типов пропов по умолчанию ТАКЖЕ происходит с помощью prop-types, что означает, что
// пропы по умолчанию должны быть правильных типов (описанных в PropTypes).
Button.defaultProps = {
	className: '',
	color: 'primary',
	size: 'md',
	type: 'button',
	disabled: false,
	onClick: undefined,
	name: undefined,
	containerName: undefined,
};

// для дальнейшего использования компонента в других частях нашего приложения, нам нужно
// обязательно экспортировать созданный компонент. Это можно сделать несколькими способами:
// 1) именованный (named) экспорт:
export { Button };
// 2) экспорт по умолчанию (таких экспортов не может быть больше одного):
// export default Button1;
